
\chapter{Einleitung und Intension}
\label{sec:EinleitungUndIntension}
Die Programmiersprache Java galt lange Zeit als langsame Programmiersprache und
auch derzeit hält sich das Gerücht weiterhin.
Mit der Version 1.1.6 änderte sich das durch die Implementierung des
Just-In-Time Compilers\cite{symantec:symantec}.
Mit weiteren Versionen wurde weiter an der Performance gearbeitet. So wurden in
der letzten Hauptversion Java 7 (Stand 12.08.2014) unter anderem parallele
Rechnungen\cite{goetz:IBM} und ein neuer Garbage Collector
eingeführt\cite{humble:infoq}.
Auch mit Java 8 wird weiterhin die Performance verbessert\cite{gallardo:oracle}.
So sollen Lambda Ausdrücke performanter sein als innere Klassen und sind mit Hauptargument für
die Umstellung und Nutzung von der neuen Java Version.
 
Diese Arbeit beschäftigt sich mit einigen neu eingeführten Funktionen in die
Programmiersprache Java der Version 8 im Vergleich zur Version 7, geht dabei
auf die dabei zu beobachtende Performance, jedoch auch auf die Komplexität und
somit dem erhöhten Nutzen ein.
 
Das erste Kapitel beschreibt die Grundlagen der Programmiersprache
Java, die allgemeine Funktionsweise und dient dem allgemeinen Verständnis der
Arbeit.
Im zweiten Kapitel wird auf die theoretischen Vor- und Nachteile der neuen
Funktionen eingegangen, welche im dritten Kapitel praktisch untersucht werden.
In der Zusammenfassung wird Bezug nehmend auf die Ergebnisse ein Vergleich mit
der Version 7 gezogen.
 
\chapter{Java Grundlagen}
\label{sec:Grundlagen}
Bei der Programmiersprache Java handelt es sich um eine objektorientierte
Programmiersprache, welche die Java Virtual Machine als Kernstück zur Ausführung
des Codes benutzt. Dabei spielen der Just-In-Time-Compiler, sowie der Garbage
Collector eine wichtige Rolle. Die grundlegenden Begriffe werden in den
Folgenden Kapiteln beschrieben.

\section{Objektorientierte Programmierung}
\label{sec:OO}
Die objektorientierte Programmierung ist ein fundamentaler Programmierstil, der
auf dem Prinzip basiert, dass der von der zu Programmierenden Sache betroffene
Bereich der Wirklichkeit als Modell in der Architektur widergespiegelt wird.
Dabei werden Konzepte wie Klassen, Objekte und Vererbung genutzt.
In der Objektorientierten Programmiersprache Java kann so zum Beispiel die
Klasse "`Buch"' den Rahmen zum Erzeugen des gleichnamigen Objektes geben. Dabei
kann das Objekt mehrere Eigenschaften und weiteren Klassen, die
wiederum Objekte erzeugen, besitzen. Ein Buchobjekt kann somit aus mehreren
Objekten "`Seite"' bestehen, welche wiederum Eigenschaften wie "`Seitenzahl"'
erhalten kann. Weiterhin können Subklassen Eigenschaften der Klasse "`Buch"'
erben und durch andere Attribute erweitert werden.
Vorteile sollen dabei sein: die Wiederverwendbarkeit von Code, die effektivere
Arbeit im Team durch Modularisierung und durch Abbildung der Wirklichkeit eine
schnellere Erlernbarkeit. Nachteile sollen im Gegensatz zu prozeduralen Sprachen
die geringere Laufzeiteffektivität und Energieeffizienz sein.

\section{Java Virtual Machine}
\label{sec:JVM}
Die Java Virtual Machine(kurz JVM) ist eine virtuelle Maschine, die
Java-Byte-Code ausführen kann. Sie ist das Grundstein jeder Java Applikation und somit
unabdingbar. Die JVM ist es die Java seine Platform- und Hardware Unabhängigkeit
gibt. Wie eine echte Rechenmaschine hat auch die JVM einen Befehlssatz und
manipuliert mehrere Speicheradressen zeitgleich. Sie verabeitet nur ein
bestimmtes Binärformat der Java Dateien, `.class` Dateien. Ansonsten weiß die
JVM nichts von der Programmiersprache Java.

\section{Just-In-Time-Compiler}
\label{sec:JIT}
Der Just-In-Time-Compiler, welcher auch kurz JIT genannt wird, wird unter
anderem auch von der Java Virtual Machine benutzt. JIT Compiler wandeln 
Quelltext Hauptsächlich zur Laufzeit in ausführbare Befehle um. Dieses Prinzip
bringt mehrere Vorteile, denn zum einen werden nur Programmteile kompiliert die
auch wirklich durchlaufen werden, was Resourcen spart. Zum anderen entfallen
lange Startzeiten, da nur ein kleiner Teil Anfangs kompiliert wird. Bei früheren
Java Versionen stellte dies ein Problem dar. Hinzu kommt, das bereits
kompilierte Teile des Programms im Cache gehalten werden, was bedeutet das der
Compiler diesen Teil nicht noch einmal durchlaufen muss.

\section{Garbage Collector}
\label{sec:GC}
Trotz des JIT Compilers ist Java eine speicherlastige Sprache, abhilfe soll hier
durch den Garbage Collector geschaffen werden. Seine Funktion besteht darin
nicht mehr benutzte Objekte aus dem Speicher aufzuspüren und diesen Speicher
wieder frei zu geben. Je nach Austattung der Systemhardware ist dies von nöten,
da die JVM theoretisch bis zu 2\textasciicircum64 Adressen zur Verfügung hat.
Natürlich nur bei 64 Bit basierten Sytemen und mit entsprechender Hardware. Beim Start kann man
jedoch meist festlegen wieviel Speicher die JVM allokieren, also für den
gebrauch reservieren und für anderen Applikationen sperren kann. Der Garbage
Collector sollte für den Benutzer kaum spürbar sein, er verrichtet seine Arbeit
meist dann wenn die Hardwarelast gering genug ist. Als Ausnahme gilt allerdings
wenn der allokierte Speicher voll ist und mehr Speicher, zum Beispiel für das
erstellen eines großen Objektes benötigt wird, denn an dieser Stelle muss der
Garbage Collector auch bei hoher Last seine Arbeit verrichten.

\chapter{Theoretische Untersuchung neuer Funktionen}
\label{sec:Theorie}

\section{Lambda Ausdrücke}
\label{sec:Lambda}
Um Lambda Ausdrücke zu verstehen sollte man den grundsätzlich Unterschied
zwischen funktionaler und imperativer Programmiersprachen kennen. In
vereinfachter Form kann man sagen, bei imperativen Herangehensweisen, welche
unter anderem bei Java vorkommt, beschreibe ich im Detail, was mein Code macht
und wie er funktioniert. Bei funktionalen Sprachen, wie Haskell, formuliert man
das Problem als Satz von Funktionen, so dass die Reihenfolge der Berechnungen
nicht angegeben werden muss. Das führt dazu das diese Reihenfolge auch garnicht
relevant ist. Was bringt uns das also? Wir können mit dem Lambda Ausdruck eine
komplexe Funktion beschreiben, welche aus mehreren Funktionen besteht und müssen
erst dann dafür sorgen das alle Bestandteile zur Verfügung stehen wenn sie
benötigt werden. Das begünstigt Verschachtelung von Funktionen, begrenzt
allerdings auch die Leserlichkeit von eben diesen Funkionen. Im speziellen ist
die Nutzung dieser Ausdrücke für Gruppen kritisch, wenn man nicht
davon ausgehen kann das alle Mitglieder Wissen über funktionale Sprachen bzw.
Ansätze aufweisen.
Lambda Ausdrücke sind anonyme Funktionen, die also nur an der Stelle benutzt
werden können an der sie beschrieben sind. Diese Tatsache ist bei der Verwendung
von Lambda Ausdrücken wichtig, denn wenn man genau weiß das man diese Funktion
noch einmal braucht, dann sollte man sie nicht als Lambda Funktion schreiben.
Lambda Ausdrücke haben die Vorteile, dass wenn man einmal geübt ist, man sich
jede Menge Code Zeilen, innere Klassen, oder komplett neue Klassen sparen kann
und der Code trotzdem noch lesbar ist. Außerdem muss die JVM dabei weniger Daten
handlen als bei anderen Herangehensweisen. Letzteres resultiert daher, das sich
Klassen bzw Funktionen der Klassen gegenseitig Objekte hin und herschieben, was
bei komplexeren Problem, bzw. Datenlastigen Objekte auch größere Dimensionen und
damit erhöhte Rechenleistung mit sich bringt.

\section{Funktionale Interfaces}
\label{sec:FI}
Neben den Lambda-Expressions haben mit Java 8 außerdem funktionale Interfaces
Einzug erhalten. Jedes Interface welche nur eine Methode besitzt, wird als
funktionales Interface bezeichnet. Interfaces mit dieser Intention erhalten in
Java die Annotation \@FunctionalInterface. Sollte das Interface nicht den
Rahmenbedingungen eines funktionalen Interface genügen wird der Kompiler einen
Fehler erzeugen. Zu erwähnen sei noch, das egal ob die Annotation vorhanden ist
oder nicht, der Kompiler wird jedes Interface, welches die Bedingungen erfüllt,
als funktionales Interface behandeln.
Funktionale Interfaces sind in der Lage Lambda Ausdrücke zu verwenden.

\section{Default-Implementierung}
\label{sec:DI}
Bisher hatte man in Java-Interfaces keine Methoden Rümpfe, doch mit der
Einführung der default-Implementierung hat sich auch das geändert. Es sind
Standardimplementierung für eine Methode eines Interfaces. Das hat zur Folge das
der Programmierer selbst eintscheiden kann, ob er eine bestimmte Methoden
überschreibt um sie für ein spezielles Objekt effektiver zu gestalten.

\section{Iterable-Interface und die forEach-Methode}
\label{sec:IIufEM}
Das Iterable-Interface ist gedacht für alle Arten von Objekte die
"`durchlaufen"' werden können. Eine Neuerung in diesen Interfaces ist die
forEach-Methode. Diese hilft bei der deutlichen Trennung von Geschäftlogik des
Objekts und dem Code. An dieser Stelle sei gesagt, dass diese Änderung am Anfang
nur nach mehr Arbeit aussieht. In Verbindung mit Lambda Ausdrücken und
Funktionalen Interfaces können damit aber sehr effektive Programme endstehen. 


\chapter{Praktische Untersuchung neuer Funktionen}
\label{sec:Praxis}

\section{Lambda Ausdrücke}
\label{sec:Lambda}

\section{Funktionale Interfaces}
\label{sec:FI}

\section{Default-Implementierung}
\label{sec:DI}

\section{Iterable-Interface und die forEach-Methode}
\label{sec:IIufEM}

\chapter{Zusammenfassung}
\label{sec:Fazit}